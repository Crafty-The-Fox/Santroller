.program pio_serialiser
.wrap_target
top2:
set y, 1
top:
set pindirs 31
irq clear 2
mov x, ~status
jmp !x top
irq set 2
write:
out pins, 2 [8]
jmp !OSRE write
jmp !y top2
set pindirs 0
top_read:
mov OSR, pins ; use OSR for getting the top two bits from pins
out X, 2 ; grab the top two bits from pins
set Y, 2 ; compare to K (note that depending on if we are in low speed or high speed, this can be either 1 or 2)
jmp X!=Y top_read [4] ; otherwise, if X isnt Y then k wasn't found
set X 0
in X, 1
read_loop:
mov y, x
mov OSR, pins ; Grab the current state of the pins
mov X, NULL
out X 2 ; store the current state in X
jmp !X end; jmp to top if we hit SE0
jmp X!=Y send_zero
send_one:
mov OSR, ~NULL
jmp end_read_loop
send_zero:
mov OSR, NULL [1]
end_read_loop:
in OSR, 1
jmp read_loop
end:
push
set y, 1
% c-sdk {
static inline void pio_serialiser_program_init(PIO pio, uint sm, uint offset, uint data_pin, float clk_div) {
    pio_gpio_init(pio, data_pin);
    pio_gpio_init(pio, data_pin + 1);
    pio_sm_config c = pio_serialiser_program_get_default_config(offset);
    sm_config_set_out_pins(&c, data_pin, 2);
    sm_config_set_clkdiv(&c, clk_div);
    sm_config_set_out_shift(&c, true, true, 8);
    sm_config_set_in_pins(&c, data_pin);
    sm_config_set_in_shift(&c, true, true, 8);
    sm_config_set_set_pins(&c, data_pin, 2);
    sm_config_set_mov_status(&c, STATUS_TX_LESSTHAN, 1);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 2, true);
    pio_sm_set_enabled(pio, sm, true);
}
%}
